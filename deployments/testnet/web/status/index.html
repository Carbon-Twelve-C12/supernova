<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supernova Network Status - Testnet</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        .header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #00ff88;
            animation: pulse 2s infinite;
        }

        .status-dot.warning {
            background: #ffaa00;
        }

        .status-dot.error {
            background: #ff3333;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.5rem;
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .metric-title {
            color: #888;
            font-size: 0.9rem;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #00ff88;
        }

        .metric-change {
            font-size: 0.8rem;
            margin-top: 0.5rem;
        }

        .positive {
            color: #00ff88;
        }

        .negative {
            color: #ff3333;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 2rem 0;
            height: 300px;
            position: relative;
        }

        .nodes-grid {
            display: grid;
            gap: 1rem;
            margin: 2rem 0;
        }

        .node-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            display: grid;
            grid-template-columns: auto 1fr auto auto;
            gap: 1rem;
            align-items: center;
        }

        .node-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff88;
        }

        .node-info h4 {
            color: #00ccff;
            margin-bottom: 0.25rem;
        }

        .node-info p {
            color: #888;
            font-size: 0.85rem;
        }

        .node-metrics {
            display: flex;
            gap: 2rem;
            font-size: 0.9rem;
        }

        .nav-tabs {
            display: flex;
            gap: 2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin: 2rem 0;
        }

        .nav-tab {
            padding: 1rem 0;
            color: #888;
            text-decoration: none;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .nav-tab.active {
            color: #00ff88;
            border-bottom-color: #00ff88;
        }

        .environmental-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .env-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
        }

        .env-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .env-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 0.5rem;
        }

        .env-label {
            color: #888;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo">Supernova Network Status</div>
                <div class="status-indicator">
                    <div class="status-dot" id="networkStatus"></div>
                    <span id="statusText">Network Operational</span>
                </div>
            </div>
        </div>
    </header>

    <main class="container">
        <div class="nav-tabs">
            <a href="#overview" class="nav-tab active">Overview</a>
            <a href="#nodes" class="nav-tab">Nodes</a>
            <a href="#environmental" class="nav-tab">Environmental</a>
        </div>

        <div id="overview" class="tab-content">
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Block Height</span>
                        <span>üìä</span>
                    </div>
                    <div class="metric-value" id="blockHeight">0</div>
                    <div class="metric-change positive">+150 last hour</div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Active Nodes</span>
                        <span>üñ•Ô∏è</span>
                    </div>
                    <div class="metric-value" id="activeNodes">0</div>
                    <div class="metric-change positive">+2 nodes</div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Transactions/sec</span>
                        <span>‚ö°</span>
                    </div>
                    <div class="metric-value" id="tps">0</div>
                    <div class="metric-change">Avg: 0.5 TPS</div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Network Hash Rate</span>
                        <span>üî®</span>
                    </div>
                    <div class="metric-value" id="hashRate">0 H/s</div>
                    <div class="metric-change positive">+10%</div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Mempool Size</span>
                        <span>üì¶</span>
                    </div>
                    <div class="metric-value" id="mempoolSize">0</div>
                    <div class="metric-change">0 pending</div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Avg Block Time</span>
                        <span>‚è±Ô∏è</span>
                    </div>
                    <div class="metric-value" id="blockTime">2.5m</div>
                    <div class="metric-change">Target: 2.5m</div>
                </div>
            </div>

            <div class="chart-container">
                <h3 style="margin-bottom: 1rem;">Network Activity (24h)</h3>
                <canvas id="activityChart"></canvas>
            </div>
        </div>

        <div id="nodes" class="tab-content" style="display: none;">
            <h2 style="margin-bottom: 1.5rem;">Connected Nodes</h2>
            <div class="nodes-grid" id="nodesList">
                <div class="node-card">
                    <div class="node-status"></div>
                    <div class="node-info">
                        <h4>Testnet Primary</h4>
                        <p>testnet.supernovanetwork.xyz</p>
                    </div>
                    <div class="node-metrics">
                        <span>Height: <strong id="node1Height">0</strong></span>
                        <span>Peers: <strong id="node1Peers">0</strong></span>
                    </div>
                    <div style="color: #00ff88;">Online</div>
                </div>
            </div>
        </div>

        <div id="environmental" class="tab-content" style="display: none;">
            <h2 style="margin-bottom: 1.5rem;">Environmental Impact Metrics</h2>
            <div class="environmental-metrics">
                <div class="env-card">
                    <div class="env-icon">üå±</div>
                    <div class="env-value" id="carbonOffset">0</div>
                    <div class="env-label">kg CO‚ÇÇ Offset</div>
                </div>
                <div class="env-card">
                    <div class="env-icon">‚ö°</div>
                    <div class="env-value" id="energyUsage">0</div>
                    <div class="env-label">kWh Energy Usage</div>
                </div>
                <div class="env-card">
                    <div class="env-icon">üåç</div>
                    <div class="env-value" id="greenScore">95%</div>
                    <div class="env-label">Green Score</div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Tab navigation
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                e.preventDefault();
                
                // Update active tab
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Show corresponding content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.style.display = 'none';
                });
                const targetId = tab.getAttribute('href').substring(1);
                document.getElementById(targetId).style.display = 'block';
            });
        });

        // API base URL - testnet uses HTTP on port 8332
        const API_BASE = 'http://testnet.supernovanetwork.xyz:8332/api/v1';

        // Format large numbers
        function formatNumber(num) {
            return new Intl.NumberFormat().format(num);
        }

        // Format hashrate
        function formatHashrate(hashrate) {
            if (hashrate === 0) return '0 H/s';
            const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s'];
            let unitIndex = 0;
            let value = hashrate;
            
            while (value >= 1000 && unitIndex < units.length - 1) {
                value /= 1000;
                unitIndex++;
            }
            
            return value.toFixed(2) + ' ' + units[unitIndex];
        }

        // Calculate average block time
        let blockTimes = [];
        let lastBlockHeight = 0;
        let lastBlockTime = Date.now();

        // Fetch network stats
        async function fetchNetworkStats() {
            try {
                // Parallel fetch all required data
                const [nodeResponse, blockchainResponse, mempoolResponse, statsResponse, networkResponse] = await Promise.all([
                    fetch(`${API_BASE}/node/info`).then(r => r.ok ? r.json() : null).catch(() => null),
                    fetch(`${API_BASE}/blockchain/info`).then(r => r.ok ? r.json() : null).catch(() => null),
                    fetch(`${API_BASE}/mempool/info`).then(r => r.ok ? r.json() : null).catch(() => null),
                    fetch(`${API_BASE}/blockchain/stats`).then(r => r.ok ? r.json() : null).catch(() => null),
                    fetch(`${API_BASE}/network/info`).then(r => r.ok ? r.json() : null).catch(() => null)
                ]);

                // Update network status
                const isConnected = nodeResponse || blockchainResponse;
                const statusDot = document.getElementById('networkStatus');
                const statusText = document.getElementById('statusText');
                
                if (isConnected) {
                    statusDot.classList.remove('error', 'warning');
                    statusText.textContent = 'Network Operational';
                } else {
                    statusDot.classList.add('error');
                    statusText.textContent = 'Connection Error';
                    return;
                }

                // Update block height
                const currentHeight = blockchainResponse?.height || nodeResponse?.height || 0;
                document.getElementById('blockHeight').textContent = formatNumber(currentHeight);
                
                // Calculate block time change
                if (lastBlockHeight > 0 && currentHeight > lastBlockHeight) {
                    const timeDiff = (Date.now() - lastBlockTime) / 1000 / 60; // minutes
                    const blockDiff = currentHeight - lastBlockHeight;
                    const avgTime = timeDiff / blockDiff;
                    blockTimes.push(avgTime);
                    
                    // Keep only last 10 measurements
                    if (blockTimes.length > 10) blockTimes.shift();
                    
                    lastBlockHeight = currentHeight;
                    lastBlockTime = Date.now();
                } else if (lastBlockHeight === 0) {
                    lastBlockHeight = currentHeight;
                    lastBlockTime = Date.now();
                }

                // Update active nodes
                const connections = networkResponse?.connections || nodeResponse?.connections || 0;
                document.getElementById('activeNodes').textContent = formatNumber(connections + 1); // +1 for self

                // Update TPS (transactions per second)
                const mempoolSize = mempoolResponse?.transaction_count || 0;
                const tps = mempoolSize > 0 ? (mempoolSize / 150).toFixed(2) : '0.00'; // Estimate based on 2.5 min blocks
                document.getElementById('tps').textContent = tps;

                // Update hashrate
                const hashrate = statsResponse?.hashrate || 0;
                document.getElementById('hashRate').textContent = formatHashrate(hashrate);

                // Update mempool size
                document.getElementById('mempoolSize').textContent = formatNumber(mempoolSize);

                // Update average block time
                if (blockTimes.length > 0) {
                    const avgBlockTime = blockTimes.reduce((a, b) => a + b, 0) / blockTimes.length;
                    document.getElementById('blockTime').textContent = avgBlockTime.toFixed(1) + 'm';
                }

                // Update node info in nodes tab
                document.getElementById('node1Height').textContent = formatNumber(currentHeight);
                document.getElementById('node1Peers').textContent = formatNumber(connections);

                // Update environmental metrics
                const uptime = nodeResponse?.uptime || 0;
                const uptimeHours = uptime / 3600;
                
                // Estimate based on efficient mining hardware (50W average)
                const energyUsage = (uptimeHours * 0.05).toFixed(2); // kWh
                const carbonOffset = (energyUsage * 0.4).toFixed(2); // kg CO2 (assuming grid average)
                
                document.getElementById('carbonOffset').textContent = carbonOffset;
                document.getElementById('energyUsage').textContent = energyUsage;
                
                // Green score based on network efficiency
                const greenScore = Math.min(95, 100 - (hashrate / 1000000)); // Simple calculation
                document.getElementById('greenScore').textContent = Math.max(50, greenScore).toFixed(0) + '%';

                // Update metric changes
                updateMetricChanges(currentHeight, connections, hashrate);
                
            } catch (error) {
                console.error('Failed to fetch network stats:', error);
                document.getElementById('networkStatus').classList.add('error');
                document.getElementById('statusText').textContent = 'Connection Error';
            }
        }

        // Track metric changes
        let previousMetrics = {
            height: 0,
            nodes: 0,
            hashrate: 0,
            timestamp: Date.now()
        };

        function updateMetricChanges(height, nodes, hashrate) {
            const now = Date.now();
            const timeDiff = (now - previousMetrics.timestamp) / 1000 / 3600; // hours
            
            if (timeDiff >= 1 || previousMetrics.height === 0) {
                // Update height change
                const heightChange = height - previousMetrics.height;
                const heightChangeEl = document.querySelector('#blockHeight').nextElementSibling.nextElementSibling;
                if (heightChange > 0) {
                    heightChangeEl.textContent = `+${heightChange} last hour`;
                    heightChangeEl.classList.add('positive');
                    heightChangeEl.classList.remove('negative');
                }
                
                // Update nodes change
                const nodesChange = nodes - previousMetrics.nodes;
                const nodesChangeEl = document.querySelector('#activeNodes').nextElementSibling.nextElementSibling;
                if (nodesChange !== 0) {
                    nodesChangeEl.textContent = nodesChange > 0 ? `+${nodesChange} nodes` : `${nodesChange} nodes`;
                    nodesChangeEl.classList.toggle('positive', nodesChange > 0);
                    nodesChangeEl.classList.toggle('negative', nodesChange < 0);
                }
                
                // Update hashrate change
                const hashrateChange = hashrate > 0 && previousMetrics.hashrate > 0 
                    ? ((hashrate - previousMetrics.hashrate) / previousMetrics.hashrate * 100).toFixed(1)
                    : 0;
                const hashrateChangeEl = document.querySelector('#hashRate').nextElementSibling.nextElementSibling;
                if (hashrateChange !== 0) {
                    hashrateChangeEl.textContent = hashrateChange > 0 ? `+${hashrateChange}%` : `${hashrateChange}%`;
                    hashrateChangeEl.classList.toggle('positive', hashrateChange > 0);
                    hashrateChangeEl.classList.toggle('negative', hashrateChange < 0);
                }
                
                // Update stored metrics
                previousMetrics = { height, nodes, hashrate, timestamp: now };
            }
        }

        // Draw activity chart with real data
        let chartData = [];
        function updateActivityChart() {
            const canvas = document.getElementById('activityChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = 250;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Add current data point
            if (chartData.length === 0 || Date.now() - chartData[chartData.length - 1].time > 60000) {
                chartData.push({
                    time: Date.now(),
                    value: parseInt(document.getElementById('mempoolSize').textContent.replace(/,/g, '')) || 0
                });
                
                // Keep only last 24 hours of data
                const cutoff = Date.now() - 24 * 60 * 60 * 1000;
                chartData = chartData.filter(d => d.time > cutoff);
            }
            
            if (chartData.length < 2) return;
            
            // Find min/max values
            const values = chartData.map(d => d.value);
            const maxValue = Math.max(...values, 10);
            const minValue = 0;
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = (i / 5) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw line chart
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            chartData.forEach((point, i) => {
                const x = (i / (chartData.length - 1)) * canvas.width;
                const y = canvas.height - ((point.value - minValue) / (maxValue - minValue)) * canvas.height;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw gradient fill
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(0, 255, 136, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
            
            ctx.fillStyle = gradient;
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
        }

        // Initial fetch and periodic updates
        fetchNetworkStats().then(() => {
            updateActivityChart();
        });
        
        // Update every 5 seconds
        setInterval(() => {
            fetchNetworkStats();
            updateActivityChart();
        }, 5000);
    </script>
</body>
</html> 